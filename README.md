# RedisFinalProject

Our group made extensions to the LAMP assignment using a Redis database. The LAMP assignment involved saving names generated by the randomuser.me API to a MariaDB database and returning a static HTML page generated by PHP that showed all the names in the database. Our group took this project and allowed users to search the MariaDB database with a live search bar without returning a whole new HTML page to display the database. We also added and used a Redis database as a caching layer to highlight Redis's speed compared to an SQL database like MariaDB. Users could search the slow MariaDB database, add names, and use a Redis database on the school server to cache all the name values into the super-fast Redis database. We also have a timing mechanism to show Redis's speed in delivering all names compared to MariaDB. 

**Website Link:** [http://csci331.cs.montana.edu:3084/](http://csci331.cs.montana.edu:3084/)

**Ivan Cline's Github:** [https://github.com/CSCI331-FinalProject/RedisFinalProject](https://github.com/CSCI331-FinalProject/RedisFinalProject)

**Matthew Keck's Github:** [https://github.com/CSCI331-FinalProject/RedisFinalProject](https://github.com/CSCI331-FinalProject/RedisFinalProject)

**Presentation Link:** [https://docs.google.com/presentation/d/1-uSCuph2nkGK3tREjWvr-9okvvUrmMS3SeQ9RJ1aNDs/edit?usp=sharing](https://docs.google.com/presentation/d/1-uSCuph2nkGK3tREjWvr-9okvvUrmMS3SeQ9RJ1aNDs/edit?usp=sharing)

## Creative Objective

The main goal of this project was to learn why Redis was becoming so popular and, more importantly, to learn how to use it or implement it in a project. Our team wanted to highlight what makes Redis different than a traditional database. Our group did this by taking the LAMP assignment that we did in class and adding to it. Initially, the LAMP assignment involved making an API call to the randomuser.me API, displaying the information returned, and giving the user the option to add this information to a MariaDB database hosted on the school server. Suppose the user had previously chosen to add this information to the database. In that case, a PHP script would run, and we would show the user a new HTML page confirming the addition of their data and all the names currently in the MariaDB database. \\ \indent The main goal was to make this experience smoother and to sneak in a Redis database as a caching layer to improve performance when delivering all of the values from the database to the user. To make the experience feel smoother, our group added a way for the user to add or ask the MariaDB database for information without generating a whole new HTML page. We also wanted to add a live search bar so that a user could confirm that the website had added their entry in a more user-friendly way. Finally, we wanted to add a timer to show the user how long it took to access the MariaDB information. We implemented a timer to use in our demonstration to highlight the increased performance when using a Redis database as a caching layer for an SQL database.

## Tech Summary

  Our project is hosted on the course server, port 3084, using NodeJS. The specific Node packages we used include `mysql`, `express`, `cors`, and `redis`. Users need to install these packages using `npm install (package name)`. We also use a MariaDB database hosted on the course server and a publicly accessible Redis database. Users can change the database credentials in the `server.js` file. To start the code, run `node server.js` from inside the `databaseTest` folder, and open the `index.html` file in the browser.

  When users enter our website, they are served a webpage from an index.HTML file with some CSS styling. This HTML page uses some inline JavaScript to make an initial API call to randomuser.me to update our HTML to show the user the information about the random person the API just generated. The user can interact with some buttons on this HTML page. There is a "Get Another" button that makes another API call to ranomuser.io and returns a different random person's information. An "Add This One" button will tell the program to add the first and last name of the person currently displayed to a MariaDB database hosted on the course server. The "Display All Data" button makes a network call to the MariaDB database, presenting all its names. It also stores all that data in the Redis database, which acts as our caching layer. The "Flush Cache" button removes all data from the Redis database, effectively flushing the cache. Finally, we have a search bar a user can use to search for names within the results that your MariaDB or Redis database returned.

  When a user presses the "Display All Data" button, our server.js file using NodeJS will check to see if there is currently any data within the Redis database or cache. Suppose there is no data within the Redis database. In that case, we will query the MariaDB database. Next, our website will add the randomly generated person's name to the database. Finally, our program will cache the information from the database in Redis for further use. Suppose there is data in the Redis database (we already have a cache). In that case, we will add the new name to the Redis cache and the MariaDB database and pull the names from the Redis database instead of making a costly call to the MariaDB database. Our live timing mechanism shows the user how long our application takes to make a network call and receive a response. Suppose the user flushes the cache and hits the "Display All Data" button. In that case, the timer will display the speed of a MariaDB database query as the user awaits the displayable data. At that point, the program caches the information in the Redis server, so if the user presses "Display All Data" again, our application will make a network call to the faster Redis database instead, showing the time it took to the user.

## Individual Member Notes

### Ivan

My contribution to the project was setting up the Redis server and the NodeJS server on which we hosted our website. I also researched Redis and how to implement it into a NodeJS-hosted website. I initially made it so we had a boring-looking site hosted on the course server using NodeJS. This website would allow users to interact directly with the randomuser.me API, the Redis, and the MariaDB database. However, there were no fancy interactions besides this. I had to talk to Scott Dowdle and Professor DeFrance about the challenges of hosting a website on the school server. Ultimately, it all worked out. The main challenge was finding a place to host the Redis server. My partner and I had planned to use a Redis database hosted on the cloud through "RedisLabs" for free, but we realized there were too many security issues when connecting to a cloud database through the school network. Instead, Scott Dowdle agreed to download Redis on the CSCI331 course server. After I resolved this issue, I did a little more research. Finally, I tied our website to the two databases, wrote code to allow users to read and write to our databases, and passed it off to my partner.

### Matthew

My contribution to the site was adding extra functionality, such as displaying the data and the user interface on the same page. I also added features like dynamically searching the database for first names. I also added a way to time the database and Redis cache so a user could see the performance increase from having a Redis cache. I also added a way to flush the Redis cache, which allowed them to experience the difference between database and Redis cache queries more than once. Finally, I included styling to our `index.html` page to make our website look pleasant.

## Conclusion

Our group gained extensive knowledge about back-end development. In particular, we learned it is challenging to set up a front-end website that directly interacts with your database if you do not have the permissions on the network. However, through communication, we were able to get our website working, and in doing so, we truly experienced the process of setting up the back end for a website and picked up details along the way. We also learned a lot about hosting databases. In particular, we learned to monitor databases using third-party tools and set up the front end to interact with them in a way that felt natural to users. Because of this project, if we need to attach a database to a website in the future. We now know that we can not only secure that database if needed, but we can also implement a Redis database to improve its performance immensely.
